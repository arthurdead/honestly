#pragma once

#include "version"
#include "memory"
#include "utility"
#include <vector>

#define CTL_REMAP_VECTOR_ACCESSORS_NOSUBSCRIPT(T, vec) \
	using iterator = typename T::iterator; \
	using const_iterator = typename T::const_iterator; \
	using reverse_iterator = typename T::reverse_iterator; \
	using const_reverse_iterator = typename T::const_reverse_iterator; \
	using reference = typename T::reference; \
	using const_reference = typename T::const_reference; \
	using value_type = typename T::value_type; \
	using size_type = typename T::size_type; \
	inline reference at(size_type pos) \
	{ return vec.at(pos); } \
	inline const_reference at(size_type pos) const \
	{ return vec.at(pos); } \
	inline reference front() \
	{ return vec.front(); } \
	inline const_reference front() const \
	{ return vec.front(); } \
	inline reference back() \
	{ return vec.back(); } \
	inline const_reference back() const \
	{ return vec.back(); } \
	inline iterator begin() noexcept \
	{ return vec.begin(); } \
	inline const_iterator begin() const noexcept \
	{ return vec.begin(); } \
	inline const_iterator cbegin() const noexcept \
	{ return vec.begin(); } \
	inline iterator end() noexcept \
	{ return vec.end(); } \
	inline const_iterator end() const noexcept \
	{ return vec.end(); } \
	inline const_iterator cend() const noexcept \
	{ return vec.cend(); } \
	inline reverse_iterator rbegin() noexcept \
	{ return vec.rbegin(); } \
	inline const_reverse_iterator rbegin() const noexcept \
	{ return vec.rbegin(); } \
	inline const_reverse_iterator crbegin() const noexcept \
	{ return vec.crbegin(); } \
	inline reverse_iterator rend() noexcept \
	{ return vec.rend(); } \
	inline const_reverse_iterator rend() const noexcept \
	{ return vec.rend(); } \
	inline const_reverse_iterator crend() const noexcept \
	{ return vec.crend(); } \
	inline size_type size() const noexcept \
	{ return vec.size(); } \
	inline bool empty() const noexcept \
	{ return vec.empty(); }

#define CTL_REMAP_VECTOR_ACCESSORS(T, vec) \
	CTL_REMAP_VECTOR_ACCESSORS_NOSUBSCRIPT(T, vec) \
	inline reference operator[](size_type pos) \
	{ return vec[pos]; } \
	inline const_reference operator[](size_type pos) const \
	{ return vec[pos]; }

namespace ctl
{
	template <typename T>
	class CTL_LOCAL_CLASS ptr_vector : private std::vector<ctl::unique_ptr<T>, ptr_allocator<T>>
	{
		using __alloc = ptr_allocator<T>;
		using __ptrtype = ctl::unique_ptr<T>;
		using __base = std::vector<__ptrtype, __alloc>;

		using __itbase = typename __base::iterator;
		using __citbase = typename __base::const_iterator;

		using __initit = typename std::initializer_list<T>::iterator;

	public:
		using size_type = typename __base::size_type;
		using value_type = T;
		using reference = T &;
		using const_reference = const T &;
		using pointer = T *;
		using const_pointer = const T *;

		class CTL_LOCAL_CLASS iterator : public __itbase
		{
		public:
			inline reference operator*() const
			{ return *__itbase::operator*(); }
			inline pointer operator->() const
			{ return __itbase::operator*().get(); }
		};

		class CTL_LOCAL_CLASS const_iterator : public __citbase
		{
		public:
			inline const_reference operator*() const
			{ return *__citbase::operator*(); }
			inline const_pointer operator->() const
			{ return __citbase::operator*().get(); }
		};

		using reverse_iterator = std::reverse_iterator<iterator>;
		using const_reverse_iterator = std::reverse_iterator<const_iterator>;

		constexpr ptr_vector() noexcept(noexcept(__alloc{})) = default;
		constexpr inline explicit ptr_vector(const __alloc &alloc) noexcept
			: __base{alloc} {}

		constexpr ptr_vector(size_type count, const T &value, const __alloc &alloc = __alloc{})
			: __base{count, alloc}
		{
			for(size_type i{0}, len{__base::size()}; i < len; ++i) {
				__base::operator[](i).reset(new T{value});
			}
		}

		constexpr explicit ptr_vector(size_type count, const __alloc &alloc = __alloc{})
			: __base{count, alloc}
		{
			for(size_type i{0}, len{__base::size()}; i < len; ++i) {
				__base::operator[](i).reset(new T);
			}
		}

		__CTL_COMMENT("TODO!!! undelete below")

		template <typename I>
		ptr_vector(I, I, const __alloc & = __alloc{}) = delete;

		constexpr ptr_vector(const ptr_vector &other)
			: __base{}
		{
			const size_type len{other.size()};
			__base::resize(len);
			for(size_type i{0}; i < len; ++i) {
				__base::operator[](i).reset(new T{*other.__base::operator[](i)});
			}
		}

		constexpr ptr_vector(const ptr_vector &other, const __alloc &alloc)
			: __base{alloc}
		{
			const size_type len{other.size()};
			__base::resize(len);
			for(size_type i{0}; i < len; ++i) {
				__base::operator[](i).reset(new T{*other.__base::operator[](i)});
			}
		}

		constexpr ptr_vector(ptr_vector &&other) noexcept = default;

		constexpr inline ptr_vector(ptr_vector &&other, const __alloc &alloc)
			: __base{std::move(other), alloc} {}

		constexpr ptr_vector(std::initializer_list<T> init, const __alloc &alloc = __alloc{})
			: __base{alloc}
		{
			const size_type len{init.size()};
			__base::resize(len);
			__initit init_begin{init.begin()};
			for(size_type i{0}; i < len; ++i, ++init_begin) {
				__base::operator[](i).reset(new T{*init_begin});
			}
		}

		constexpr ptr_vector &operator=(const ptr_vector &other)
		{
			size_type len{other.size()};
			__base::resize(len);
			for(size_type i{0}; i < len; ++i) {
				__base::operator[](i).reset(new T{*other.__base::operator[](i)});
			}
			return *this;
		}

		constexpr ptr_vector &operator=(ptr_vector &&other) = default;

		constexpr inline ptr_vector &operator=(std::initializer_list<T> ilist)
		{ ptr_vector::assign(ilist); return *this; }

		constexpr void assign(size_type count, const T &value)
		{
			__base::resize(count);
			for(size_type i{0}; i < count; ++i) {
				__base::operator[](i).reset(new T{value});
			}
		}

		__CTL_COMMENT("TODO!!! undelete below")

		template <typename I>
		void assign(I, I) = delete;

		constexpr void assign(std::initializer_list<T> ilist)
		{
			const size_type len{ilist.size()};
			__base::resize(len);
			__initit listbegin{ilist.begin()};
			for(size_type i{0}; i < len; ++i, ++listbegin) {
				__base::operator[](i).reset(new T{*listbegin});
			}
		}

		constexpr inline reference at(size_type pos)
		{ return *__base::at(pos); }
		constexpr inline const_reference at(size_type pos) const
		{ return *__base::at(pos); }

		constexpr inline reference operator[](size_type pos)
		{ return *__base::operator[](pos); }
		constexpr inline const_reference operator[](size_type pos) const
		{ return *__base::operator[](pos); }

		constexpr inline reference front()
		{ return *__base::front(); }
		constexpr inline const_reference front() const
		{ return *__base::front(); }

		constexpr inline reference back()
		{ return *__base::back(); }
		constexpr inline const_reference back() const
		{ return *__base::back(); }

		T *data() = delete;
		const T *data() const = delete;

		constexpr inline iterator begin() noexcept
		{ return type_cast<iterator>(__base::begin()); }
		constexpr inline const_iterator begin() const noexcept
		{ return type_cast<const_iterator>(__base::begin()); }
		constexpr inline const_iterator cbegin() const noexcept
		{ return type_cast<const_iterator>(__base::begin()); }
		constexpr inline iterator end() noexcept
		{ return type_cast<iterator>(__base::end()); }
		constexpr inline const_iterator end() const noexcept
		{ return type_cast<const_iterator>(__base::end()); }
		constexpr inline const_iterator cend() const noexcept
		{ return type_cast<const_iterator>(__base::cend()); }
		constexpr inline reverse_iterator rbegin() noexcept
		{ return type_cast<reverse_iterator>(__base::rbegin()); }
		constexpr inline const_reverse_iterator rbegin() const noexcept
		{ return type_cast<const_reverse_iterator>(__base::rbegin()); }
		constexpr inline const_reverse_iterator crbegin() const noexcept
		{ return type_cast<const_reverse_iterator>(__base::crbegin()); }
		constexpr inline reverse_iterator rend() noexcept
		{ return type_cast<reverse_iterator>(__base::rend()); }
		constexpr inline const_reverse_iterator rend() const noexcept
		{ return type_cast<const_reverse_iterator>(__base::rend()); }
		constexpr inline const_reverse_iterator crend() const noexcept
		{ return type_cast<const_reverse_iterator>(__base::crend()); }

		using __base::empty;
		using __base::size;
		using __base::max_size;
		using __base::reserve;
		using __base::capacity;
		using __base::shrink_to_fit;
		using __base::clear;

		constexpr inline iterator insert(const_iterator pos, const T &value)
		{ return __base::insert(pos, new T{value}); }
		constexpr inline iterator insert(const_iterator pos, T &&value)
		{ return __base::insert(pos, new T{std::move(value)}); }

		constexpr iterator insert(const_iterator pos, size_type count, const T &value)
		{
			__CTL_COMMENT("TODO!!! do this smarter")

			__ptrtype ignore;
			iterator ret{__base::insert(pos, count, std::move(ignore))};
			iterator tmp{ret};
			for(size_type i{0}; i < count; ++i, ++tmp) {
				tmp->reset(new T{value});
			}
			return ret;
		}

		__CTL_COMMENT("TODO!!! undelete below")

		template <typename I>
		iterator insert(const_iterator, I, I) = delete;

		constexpr iterator insert(const_iterator pos, std::initializer_list<T> ilist)
		{
			__CTL_COMMENT("TODO!!! do this smarter")

			size_type len{ilist.size()};
			__ptrtype ignore;
			iterator ret{__base::insert(pos, len, std::move(ignore))};
			iterator tmp{ret};
			__initit listbegin{ilist.begin()};
			for(size_type i{0}; i < len; ++i, ++tmp, ++listbegin) {
				tmp->reset(new T{*listbegin});
			}
			return ret;
		}

		template <typename ...Args>
		constexpr inline iterator emplace(const_iterator pos, Args && ...args)
		{ return __base::emplace(pos, new T{std::forward<Args>(args)...}); }

		constexpr inline iterator erase(iterator pos)
		{ return type_cast<iterator>(__base::erase(type_cast<__itbase>(pos))); }

		constexpr inline iterator erase(iterator first, iterator last)
		{ return type_cast<iterator>(__base::erase(type_cast<__itbase>(first), type_cast<__itbase>(last))); }

		constexpr inline iterator erase(const_iterator pos)
		{ return type_cast<iterator>(__base::erase(type_cast<__citbase>(pos))); }
		constexpr inline iterator erase(const_iterator first, const_iterator last)
		{ return type_cast<iterator>(__base::erase(type_cast<__citbase>(first), type_cast<__citbase>(last))); }

		constexpr inline void push_back(const T &value)
		{ __base::push_back(new T{value}); }
		constexpr inline void push_back(T &&value)
		{ __base::push_back(new T{std::move(value)}); }

		template <typename ...Args>
		constexpr inline reference emplace_back(Args && ...args)
		{ return *__base::emplace_back(new T{std::forward<Args>(args)...}); }

		using __base::pop_back;

		constexpr void resize(size_type count)
		{
			size_type oldlen{__base::size()};
			__base::resize(count);
			if(count > oldlen) {
				for(size_type i{oldlen}; i < count; ++i) {
					__base::operator[](i).reset(new T);
				}
			}
		}

		constexpr void resize(size_type count, const value_type &value)
		{
			size_type oldlen{__base::size()};
			__base::resize(count);
			if(count > oldlen) {
				for(size_type i{oldlen}; i < count; ++i) {
					__base::operator[](i).reset(new T{value});
				}
			}
		}

		__CTL_COMMENT("TODO!!! undelete below")

		void swap(ptr_vector &) = delete;
	};
}
